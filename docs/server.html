
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Server &#8212; pyOpenADR 0.4.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/css/custom.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Ready-to-Run Examples" href="examples.html" />
    <link rel="prev" title="Client" href="client.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="server">
<span id="id1"></span><h1>Server<a class="headerlink" href="#server" title="Permalink to this headline">¶</a></h1>
<p>If you are implementing an OpenADR Server (“Virtual Top Node”) using pyOpenADR, read this page.</p>
<div class="section" id="registration">
<span id="server-registration"></span><h2>Registration<a class="headerlink" href="#registration" title="Permalink to this headline">¶</a></h2>
<p>If a client (VEN) wants to register for the first time, it will go through a Registration procedure.</p>
<div class="admonition-implementation-checklist admonition">
<p class="admonition-title">Implementation Checklist</p>
<ol class="arabic simple">
<li><p>Create a handler that decides what to do with new registrations, based on their <code class="docutils literal notranslate"><span class="pre">venID</span></code>.</p></li>
</ol>
</div>
<p>The client will send a <a class="reference internal" href="representations.html#oadrqueryregistration"><span class="std std-ref">oadrQueryRegistration</span></a> message. The server will respond with a <a class="reference internal" href="representations.html#oadrcreatedpartyregistration"><span class="std std-ref">oadrCreatedPartyRegistration</span></a> message containing a list of its capabilities, notably the implemented OpenADR protocol versions and the available Transport Mechanisms (HTTP and/or XMPP).</p>
<p>The client will then usually send a <a class="reference internal" href="representations.html#oadrcreatepartyregistration"><span class="std std-ref">oadrCreatePartyRegistration</span></a> message, in which it registers to a specific OpenADR version and Transport Method. The server must then decide what it wants to do with this registration.</p>
<p>In the case that the registration is accepted, the VTN will generate a RegistrationID for this VEN and respond with a <a class="reference internal" href="representations.html#oadrcreatedpartyregistration"><span class="std std-ref">oadrCreatedPartyRegistration</span></a> message.</p>
<p>In your application, when a VEN sends a <a class="reference internal" href="representations.html#oadrcreatepartyregistration"><span class="std std-ref">oadrCreatePartyRegistration</span></a> request, it will call your <code class="docutils literal notranslate"><span class="pre">on_register_party</span></code> handler. This handler must somehow look up what to do with this request, and respond with a <code class="docutils literal notranslate"><span class="pre">registration_id</span></code>.</p>
<p>Example implementation:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyopenadr.utils</span> <span class="kn">import</span> <span class="n">generate_id</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">on_create_party_registration</span><span class="p">(</span><span class="n">payload</span><span class="p">):</span>
    <span class="n">ven_id</span> <span class="o">=</span> <span class="n">payload</span><span class="p">[</span><span class="s1">&#39;ven_id&#39;</span><span class="p">]</span>
    <span class="c1"># Check whether or not this VEN is allowed to register</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">database</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;SELECT COUNT(*)</span>
<span class="s2">                                       FROM vens</span>
<span class="s2">                                      WHERE ven_id = ?&quot;&quot;&quot;</span><span class="p">,</span>
                                  <span class="p">(</span><span class="n">payload</span><span class="p">[</span><span class="s1">&#39;ven_id&#39;</span><span class="p">],))</span>
    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Generate an ID for this registration</span>
        <span class="n">registration_id</span> <span class="o">=</span> <span class="n">generate_id</span><span class="p">()</span>

        <span class="c1"># Store the registration in a database (pseudo-code)</span>
        <span class="k">await</span> <span class="n">database</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;UPDATE vens</span>
<span class="s2">                                   SET registration_id = ?</span>
<span class="s2">                                 WHERE ven_id = ?&quot;&quot;&quot;</span><span class="p">,</span>
                             <span class="p">(</span><span class="n">registration_id</span><span class="p">,</span> <span class="n">ven_id</span><span class="p">))</span>

        <span class="c1"># Return the registration ID.</span>
        <span class="c1"># This will be put into the correct form by the OpenADRServer.</span>
        <span class="k">return</span> <span class="n">registration_id</span>
</pre></div>
</div>
</div>
<div class="section" id="events">
<span id="server-events"></span><h2>Events<a class="headerlink" href="#events" title="Permalink to this headline">¶</a></h2>
<p>The server (VTN) is expected to know when it needs to inform the clients (VENs) of certain events that they must respond to. This could be a predicted shortage or overage of available power in a certain electricity grid area, for example.</p>
<p>The VTN must determine when VENs are relevant and which Events to send to them. The next time the VEN polls for new messages (using a <a class="reference internal" href="representations.html#oadrpoll"><span class="std std-ref">oadrPoll</span></a> or <a class="reference internal" href="representations.html#oadrrequestevent"><span class="std std-ref">oadrRequestEvent</span></a> message), it will send the Event in a <a class="reference internal" href="representations.html#oadrdistributeevent"><span class="std std-ref">oadrDistributeEvent</span></a> message to the client. The client will then evaluate whether or not it indends to comply with the request, and respond with an <a class="reference internal" href="representations.html#oadrcreatedevent"><span class="std std-ref">oadrCreatedEvent</span></a> message containing an optStatus of <code class="docutils literal notranslate"><span class="pre">'optIn'</span></code> or <code class="docutils literal notranslate"><span class="pre">'optOut'</span></code>.</p>
<div class="admonition-implementation-checklist admonition">
<p class="admonition-title">Implementation Checklist</p>
<p>In your application, the creation of Events is completely up to you. PyOpenADR will only call your <code class="docutils literal notranslate"><span class="pre">on_poll</span></code> handler with a <code class="docutils literal notranslate"><span class="pre">ven_id</span></code>. This handler must be able to either retrieve the next event for this VEN out of some storage or queue, or make up the Event in real time.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">on_created_event(payload)</span></code> handler is called whenever the VEN sends an <a class="reference internal" href="representations.html#oadrcreatedevent"><span class="std std-ref">oadrCreatedEvent</span></a> message, probably informing you of what they intend to do with the event you gave them.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_request_event(ven_id)</span></code>: this should return the next event (if any) that you have for the VEN. If you return <code class="docutils literal notranslate"><span class="pre">None</span></code>, a blank <a class="reference internal" href="representations.html#oadrresponse"><span class="std std-ref">oadrResponse</span></a> will be returned to the VEN.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_request_report(ven_id)</span></code>: this should return then next report (if any) that you have for the VEN. If you return None, a blank <a class="reference internal" href="representations.html#oadrresponse"><span class="std std-ref">oadrResponse</span></a> will be returned to the VEN.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_poll(ven_id)</span></code>: this should return the next message in line, which is usually either a new <a class="reference internal" href="representations.html#oadrupdatedreport"><span class="std std-ref">oadrUpdatedReport</span></a> or a <a class="reference internal" href="representations.html#oadrdistributeevent"><span class="std std-ref">oadrDistributeEvent</span></a> message.</p></li>
</ul>
</div>
<p>The Event consists of three main sections:</p>
<ol class="arabic simple">
<li><p>A time period for when this event is supposed to be active</p></li>
<li><p>A list of Targets to which the Event applies. This can be the VEN as a whole, or specific groups, assets, geographic areas, et cetera that this VEN represents.</p></li>
<li><p>A list of Signals, which form the content of the Event. This can be price signals, load reduction signals, et cetera. Each signal has a name, a type, multiple Intervals that contain the relative start times, and some payload value for the client to interpret.</p></li>
</ol>
</div>
<div class="section" id="reports">
<span id="server-reports"></span><h2>Reports<a class="headerlink" href="#reports" title="Permalink to this headline">¶</a></h2>
<p>Reporting is probably the most complicated of interactions within OpenADR. It involves the following steps:</p>
<ol class="arabic simple">
<li><p>Party A makes its reporting capabilities known to party B using a <span class="xref std std-ref">oadrRegisterReport</span> message.</p></li>
<li><p>Party B responds with an <a class="reference internal" href="representations.html#oadrregisteredreport"><span class="std std-ref">oadrRegisteredReport</span></a> message, optionally including an <span class="xref std std-ref">oadrReportRequest</span> section that tells party A which party B is interested in.</p></li>
<li><p>Party A reponds with an oadrCreatedReport message telling party B that it will periodically generate the reports.</p></li>
</ol>
<p>This ceremony is performed once with the VTN as party A and once with the VEN as party A.</p>
<p>The VEN party can collect the reports it requested from the VTN using either the <a class="reference internal" href="representations.html#oadrpoll"><span class="std std-ref">oadrPoll</span></a> or <span class="xref std std-ref">oadrRequestReport</span> messages. The VTN will respond with an <a class="reference internal" href="representations.html#oadrupdatereport"><span class="std std-ref">oadrUpdateReport</span></a> message containing the actual report. The VEN should then respond with a <a class="reference internal" href="representations.html#oadrupdatedreport"><span class="std std-ref">oadrUpdatedReport</span></a> message.</p>
<p>The VEN should actively supply the reports to the VTN using <a class="reference internal" href="representations.html#oadrupdatereport"><span class="std std-ref">oadrUpdateReport</span></a> messages, to which the VTN will respond with <a class="reference internal" href="representations.html#oadrupdatedreport"><span class="std std-ref">oadrUpdatedReport</span></a> messages.</p>
<div class="admonition-implementation-checklist admonition">
<p class="admonition-title">Implementation Checklist</p>
<p>To benefit from the automatic reporting engine in pyOpenADR, you should implement the following items yourself:</p>
<ol class="arabic simple">
<li><p>Configure the OpenADRServer() instance with your reporting capabilities and requirements</p></li>
<li><p>Implement a handlers that can retrieve the reports from your backend system</p></li>
<li><p>Implement a handler that deal with reports that come in from the clients</p></li>
</ol>
</div>
</div>
<div class="section" id="things-you-should-implement">
<span id="server-implement"></span><h2>Things you should implement<a class="headerlink" href="#things-you-should-implement" title="Permalink to this headline">¶</a></h2>
<p>You should implement the following handlers:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">on_poll(ven_id)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_request_event(ven_id)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_request_report(payload)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_create_party_registration(payload)</span></code></p></li>
</ul>
</div>
<div class="section" id="non-openadr-signals-from-the-server">
<span id="server-meta"></span><h2>Non-OpenADR signals from the server<a class="headerlink" href="#non-openadr-signals-from-the-server" title="Permalink to this headline">¶</a></h2>
<p>The pyOpenADR Server can call the following handlers, which are not part of the regular openADR communication flow, but can help you develop a more robust event-driven system:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">on_ven_online(ven_id)</span></code>: called when a VEN sends an <a class="reference internal" href="representations.html#oadrpoll"><span class="std std-ref">oadrPoll</span></a>, <a class="reference internal" href="representations.html#oadrrequestevent"><span class="std std-ref">oadrRequestEvent</span></a> or <span class="xref std std-ref">oadrRequestReport</span> message after it had been offline before.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">on_ven_offline(ven_id)</span></code>: called when a VEN misses 3 consecutive poll intervals (configurable).</p></li>
</ul>
<p>Example implementation:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyopenadr</span> <span class="kn">import</span> <span class="n">OpenADRServer</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">OpenADRServer</span><span class="p">(</span><span class="n">vtn_id</span><span class="o">=</span><span class="s1">&#39;MyVTN&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span><span class="s1">&#39;on_ven_online&#39;</span><span class="p">,</span> <span class="n">on_ven_online</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span><span class="s1">&#39;on_ven_offline&#39;</span><span class="p">,</span> <span class="n">on_ven_offline</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">on_ven_online</span><span class="p">(</span><span class="n">ven_id</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;VEN </span><span class="si">{</span><span class="n">ven_id</span><span class="si">}</span><span class="s2"> is now online again!&quot;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">on_ven_offline</span><span class="p">(</span><span class="n">ven_id</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;VEN </span><span class="si">{</span><span class="n">ven_id</span><span class="si">}</span><span class="s2"> has gone AWOL&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="signing-messages">
<span id="server-signing-messages"></span><h2>Signing Messages<a class="headerlink" href="#signing-messages" title="Permalink to this headline">¶</a></h2>
<p>The pyOpenADR can sign your messages and validate incoming messages. For some background, see the <a class="reference internal" href="message_signing.html#message-signing"><span class="std std-ref">Message Signing</span></a>.</p>
<p>Example implementation:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyopenadr</span> <span class="kn">import</span> <span class="n">OpenADRServr</span>

<span class="k">def</span> <span class="nf">fingerprint_lookup</span><span class="p">(</span><span class="n">ven_id</span><span class="p">):</span>
    <span class="c1"># Look up the certificate fingerprint that is associated with this VEN.</span>
    <span class="n">fingerprint</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s1">&#39;certificate_fingerprint&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ven_id</span><span class="o">=</span><span class="n">ven_id</span><span class="p">)</span> <span class="c1"># Pseudo code</span>
    <span class="k">return</span> <span class="n">fingerprint</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">OpenADRServer</span><span class="p">(</span><span class="n">vtn_id</span><span class="o">=</span><span class="s1">&#39;MyVTN&#39;</span><span class="p">,</span>
                       <span class="n">cert</span><span class="o">=</span><span class="s1">&#39;/path/to/cert.pem&#39;</span><span class="p">,</span>
                       <span class="n">key</span><span class="o">=</span><span class="s1">&#39;/path/to/private/key.pem&#39;</span><span class="p">,</span>
                       <span class="n">passphrase</span><span class="o">=</span><span class="s1">&#39;mypassphrase&#39;</span><span class="p">,</span>
                       <span class="n">validation_handler</span><span class="o">=</span><span class="n">fingerprint_lookup</span><span class="p">)</span>
</pre></div>
</div>
<p>The VEN’s fingerprint should be obtained from the VEN outside of OpenADR.</p>
</div>
<div class="section" id="message-handlers">
<span id="server-message-handlers"></span><h2>Message Handlers<a class="headerlink" href="#message-handlers" title="Permalink to this headline">¶</a></h2>
<p>Your server has to deal with the different OpenADR messages. The way this works is that pyOpenADR will expose certain modules at the appropriate endpoints (like /oadrPoll and /EiRegister), and figure out what type of message is being sent. It will then call your handler with the contents of the message that are relevant for you to handle. This section provides an overview with examples for the different kinds of messages that you can expect and what should be returned.</p>
<div class="section" id="on-created-event">
<span id="server-on-created-event"></span><h3>on_created_event<a class="headerlink" href="#on-created-event" title="Permalink to this headline">¶</a></h3>
<p>The VEN informs you that they created an Event that you sent to them. You don’t have to return anything.</p>
<p>Return: <cite>None</cite></p>
</div>
<div class="section" id="on-request-event">
<span id="server-on-request-event"></span><h3>on_request_event<a class="headerlink" href="#on-request-event" title="Permalink to this headline">¶</a></h3>
<p>The VEN is requesting the next Event that you have for it. You should return an Event. If you have no Events for this VEN, you should return <cite>None</cite>.</p>
</div>
<div class="section" id="on-register-report">
<span id="server-on-register-report"></span><h3>on_register_report<a class="headerlink" href="#on-register-report" title="Permalink to this headline">¶</a></h3>
<p>The VEN informs you which reports it has available. If you want to periodically receive any of these reports, you should return a list of the r_ids that you want to receive.</p>
<p>Return: list of report_ids.</p>
</div>
<div class="section" id="on-created-report">
<span id="server-on-created-report"></span><h3>on_created_report<a class="headerlink" href="#on-created-report" title="Permalink to this headline">¶</a></h3>
<p>The VEN informs you that it created the automatic reporting that you requested. You don’t have to return anything.</p>
<p>Return: <cite>None</cite></p>
</div>
<div class="section" id="on-update-report">
<span id="server-on-update-report"></span><h3>on_update_report<a class="headerlink" href="#on-update-report" title="Permalink to this headline">¶</a></h3>
<p>The VEN is sending you a fresh report with data. You don’t have to return anything.</p>
<p>Signature:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">on_update_report</span><span class="p">(</span><span class="n">ven_id</span><span class="p">,</span> <span class="n">report</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
<div class="section" id="on-poll">
<span id="server-on-poll"></span><h3>on_poll<a class="headerlink" href="#on-poll" title="Permalink to this headline">¶</a></h3>
<p>The VEN is requesting the next message that you have for it. You should return a tuple of message_type and message_payload as a dict. If there is no message for the VEN, you should return <cite>None</cite>.</p>
<p>Signature:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">on_poll</span><span class="p">(</span><span class="n">ven_id</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">message_type</span><span class="p">,</span> <span class="n">message_payload</span>
</pre></div>
</div>
</div>
<div class="section" id="on-query-registration">
<span id="server-on-query-registration"></span><h3>on_query_registration<a class="headerlink" href="#on-query-registration" title="Permalink to this headline">¶</a></h3>
<p>A prospective VEN is requesting information about your VTN, like the versions and transports you support. You should not implement this handler and let pyOpenADR handle this response.</p>
</div>
<div class="section" id="on-create-party-registration">
<span id="server-on-create-party-registration"></span><h3>on_create_party_registration<a class="headerlink" href="#on-create-party-registration" title="Permalink to this headline">¶</a></h3>
<p>The VEN tries to register with you. You will probably have manually configured the VEN beforehand, so you should look them up by their ven_name. You should have a ven_id that you generated ready.
If they are allowed to register, return the ven_id (str), otherwise return False.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">on_create_party_registration</span><span class="p">(</span><span class="n">ven_name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ven_is_known</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ven_id</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
<div class="section" id="on-cancel-party-registration">
<span id="server-on-cancel-party-registration"></span><h3>on_cancel_party_registration<a class="headerlink" href="#on-cancel-party-registration" title="Permalink to this headline">¶</a></h3>
<p>The VEN informs you that they are cancelling their registration and no longer wish to be contacted by you.</p>
<p>You should deregister the VEN internally, and return <cite>None</cite>.</p>
<p>Return: <cite>None</cite></p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">pyOpenADR</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="features.html">Feature Tour</a></li>
<li class="toctree-l1"><a class="reference internal" href="openadr.html">OpenADR Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="client.html">Client</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Server</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#registration">Registration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#events">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reports">Reports</a></li>
<li class="toctree-l2"><a class="reference internal" href="#things-you-should-implement">Things you should implement</a></li>
<li class="toctree-l2"><a class="reference internal" href="#non-openadr-signals-from-the-server">Non-OpenADR signals from the server</a></li>
<li class="toctree-l2"><a class="reference internal" href="#signing-messages">Signing Messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#message-handlers">Message Handlers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Ready-to-Run Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="roadmap.html">Project Status and Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="representations.html">Payload Representations</a></li>
<li class="toctree-l1"><a class="reference internal" href="message_signing.html">Message Signing</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/modules.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="client.html" title="previous chapter">Client</a></li>
      <li>Next: <a href="examples.html" title="next chapter">Ready-to-Run Examples</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Stan Janssen.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/server.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>